# Python 语言的高级特性
- 基于lambda演算的一种编程方式
    - 程序中只有函数
    - 函数可以作为参数，同样可以作为返回值
    - 纯函数式编程语言：LISP，Haskell
- Python函数式编程只是借鉴函数式编程的一些特点可以理解成一半函数式一半python
- 内容
    - 高阶函数
    - 返回函数
    - 匿名函数
    - 装饰器
    - 偏函数
# lambda表达式
- 函数：最大程度复用代码
    - 存在问题：如果函数很小，很短，会变得麻烦
    - 如果函数被调用次数少，则会造成浪费
    - 对阅读者来说，造成函数流程的被迫中断
- lambda表达式（匿名函数）
    - 一个表达式，函数体相对简单
    - 不是一个代码块，仅仅是一个表达式
    - 可以有参数，有多个参数需要用逗号隔开
    - lambda表达式的用法
        - 以lambda开头
        - 紧跟一定的参数（如果有）
        - 参数后用冒号和表达式主题隔开
        - 只是一个表达式，所以，没有return
        - 举例：
                # 计算一个数的100倍数
                # 因为就是一个表达式，所以没有return
                stm = lambda x:100*x
                stm(89)
                输出：8900
                stm = lambda x,y,z: x+ y*10 +z*100
                stm2(4,5,6)
                输出：654
                
# 高阶函数
- 把函数作为参数使用的函数，叫高阶函数
- 既然函数名称是变量，则应该可以被当作参数传入另一个函数
- 举例:
        # funA是普通函数，返回一个传入数字的100倍数字
        def funA(n)：
            return n * 100
        # 再写一个函数，把传入参数乘以300倍数
        def funB(n):
            return funA(n)*3
           
        print(funB(n))
        
        # 第二种：高阶函数
        def funC(n,f):
            #假定函数是把n扩大100倍
            return f(n)*3
            
        print(funC(9,funA))
        # 比较funC和funB,显然funC的写法要优于funB
        # 例如：
        def funD(n):
            return n*10
        # 需求变更，需要把n放大30倍，此时funB无法实现
        print(funC(7,funD))
        
# 系统高阶函数-map
- 原意就是映射，即把集合或者列表的元素，每一个元素都按照一定规则进行操作，生成一个
   新的列表或者集合
- map函数是系统提供的具有映射功能的函数，返回值是一个迭代对象
- 举例：
        # 将一个列表里的每一个参数乘以10，重新生成一个新列表
        l1 = [i for i in range(10)]
        print(l1)
        l2 = []
        for i in l1:
            l2.append(i*10)
        print(l2)

        # 用map函数实现
        def mulTen(n):
            return n*10

        l3 = map(mulTen,l1)
        print(l3)

        for i in l3:
            print(i,end=',')

        print()
        l4 = [i for i in l3]
        print(l4)
        
# renduce
- 原意是归并，缩减
- 把一个可迭代对象最后归并成一个结果
- 对于作为参数的函数要求:必须有两个参数，必须有返回结果
- reduce([1,2,3,4,5]) == f(f(f(f(1,2)3)4)5)
- reduce 需要导入functools包
- 举例：
         from functools import reduce
         # 定义一个操作函数
         # 加入操作函数只是相加
         def myAdd(x,y):
             return x + y

         # 对于列表[1,2,3,4,5]执行myAdd函数的reduce
         rst = reduce(myAdd,[1,2,3,4,5])
         print(rst)
 
# 高阶函数-排序
- 把一个序列按照给定算法进行排序
- key：在排序前对每一个元素进行key函数运算，可以理解成key函数定义逻辑进行排序
- python2和python3相差巨大
- 举例：参照04_sorted.py

# 返回函数
- 函数可以返回具体的值
- 也可以返回一个函数作为结果
- 举例：05_返回函数.py

# 闭包(closure)
- 当一个函数在内部定义函数，并且内部的函数应用外部函数的参数后者局部变量，当内部函数
  被当作返回值得时候，相关参数和变量保存在返回函数中，这种结果，叫闭包
- 上面定义的myF4是一个标准闭包结构
- 闭包的常见坑：06_闭包.py
    - 造成上述状况的原因是，返回函数引用了变量i，i并非立即执行
      而是等到三个函数都返回的时候才统一使用，此时i已经变成了3
      最终调用的时候，都返回的是3*3
    - 此问题描述成：返回闭包时，返回函数不能引用任何循环变量
    - 解决方案：再创建一个函数，用该函数的参数绑定循环变量的当
      前值，无论该循环变量以后如何改变，已经绑定的函数参数值不再改变

# 装饰器
- 07_hello.py
- 在不改动函数代码的基础上无限制扩展函数功能的一种机制，本质上讲，装饰器是一个返回函数的高阶函数
- 装饰器的使用：使用@语法，即在每次要扩展到函数定义前使用@+函数名
- 举例：08_decrator.py
- 装饰器的好处，一点定义，则可以装饰任意函数
- 一旦被其装饰，则把装饰器的功能直接添加到定义函数的功能上
- 上面对函数的装饰使用了系统定义的语法糖，也可以手动执行下装饰器

# 偏函数
- 参数固定的函数，相当于一个由特定参数的函数体
- functools.partial的作用是，把一个函数某些函数固定，返回一个新函数
- 举例：09.偏函数.py

# 高级函数补充
- zip
    - 定义：把两个可迭代内容生成一个可迭代的tuple元组类型组成的内容
    - 举例：10_zip.py
    
- enumerate
    - 跟zip功能类似
    - 对可迭代对象里的每一元素，配上一个索引，然后索引和内容构成tuple类型
    - 举例：11_enumerate.py
    
- collections模块
    - namedtuple
        - tuple类型，是一个可命名的tuple
        - 举例：12_namedtuple.py

- dequeue
    - 比较方便的解决了频繁删除插入带来的效率问题
    - 举例：13_deque.py
    
- defualtdict
    - 当直接读取dict不存在的属性，直接返回默认值
    - 举例：14_defualtdict.py
    
- Counter
    - 统计字符串个数
    - 举例：15_Counter.py        
                            
             
        
                           